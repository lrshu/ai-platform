这份指南去除了理论概念，专注于实战。以下是供开发者直接参考的 **LLM（大语言模型）高效使用手册**。

### 核心原则：怎么问才有效？

1.  **给示例（最有效）**：不要只说“转成 JSON”，给它看一个“输入->输出”的样本。
2.  **指定上下文**：明确语言、版本、库、甚至变量命名风格。
3.  **拆解步骤**：遇到复杂逻辑，强制要求模型“一步步思考”或按序号输出。
4.  **定义输出格式**：明确要求输出 Markdown、纯代码块、JSON 还是 CSV。

---

### 场景化指南

#### 1. 写代码 (Code Generation)

不要只说“写个爬虫”。

- **❌ 差**：“用 Python 写个爬取网页的脚本。”
- **✅ 好**：“使用 **Python 3.10** 和 **BeautifulSoup4**。编写一个脚本解析 `data.html`，提取所有 `<div class='price'>` 中的文本，并保存为 **CSV 文件**。不要包含 markdown 解释，直接给代码。”

#### 2. 调试与报错 (Debugging)

不要只贴代码。

- **❌ 差**：“这段代码报错了怎么办？”
- **✅ 好**：“我运行这段代码时遇到了 `IndexError: list index out of range`。这是代码上下文：[粘贴代码]。请指出错误原因，并给出修复后的代码块。”

#### 3. 写 SQL (Database)

必须提供表结构，否则模型只能瞎猜。

- **❌ 差**：“帮我查一下上个月下单最多的用户。”
- **✅ 好**：“基于以下表结构生成 MySQL 查询：
  - `Orders` 表: `order_id`, `user_id`, `order_date`, `amount`
  - `Users` 表: `user_id`, `username`
    **任务**：找出上个月订单总金额最高的前 5 名用户。”

#### 4. 解释代码 (Code Explanation)

用于接手旧项目或学习新语法。

- **❌ 差**：“这是什么意思？”
- **✅ 好**：“请用**伪代码**或**注释**的形式解释这段正则/Shell 命令的逻辑，重点解释参数 `-x` 和 `-f` 的作用。”

#### 5. 单元测试 (Unit Testing)

让 AI 帮你想边缘情况。

- **✅ 模版**：“请为以下函数编写 `Jest` 测试用例。涵盖正常输入、空输入、非法字符以及边界值情况：[粘贴函数]”

---

### 提效技巧 (Copy & Paste)

在提示词末尾加上这些指令，可以显著提高结果质量：

- **只看代码**：
  > “请只输出代码块，不要任何解释性文字。”
- **优化性能**：
  > “请重构这段代码，将时间复杂度从 O(n^2) 优化到 O(n)。”
- **规范化**：
  > “请遵循 Google Java Style Guide 重写这段代码，并添加必要的 Javadoc。”
- **防御性编程**：
  > “请添加错误处理（Try-Catch），防止因输入为空导致崩溃。”

---

### 常用速查表

| 需求           | 推荐提示词结构                                                                       |
| :------------- | :----------------------------------------------------------------------------------- |
| **正则生成**   | “写一个正则匹配 [规则]，并提供 3 个匹配成功和 3 个匹配失败的测试用例。”              |
| **代码转换**   | “将这段 [Java] 代码重写为 [Kotlin]，使用惯用的语法糖（Idiomatic）。”                 |
| **数据生成**   | “生成 10 条测试数据，JSON 格式，包含字段：id (UUID), name (随机人名), age (18-60)。” |
| **Git Commit** | “根据以下 `git diff` 内容，写一个简洁的 Commit Message：[粘贴 diff]”                 |

### 想要我为你生成具体的代码或解决报错吗？

请直接粘贴你的**需求**或**错误代码**。
